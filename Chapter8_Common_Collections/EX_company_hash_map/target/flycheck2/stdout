{"reason":"compiler-message","package_id":"path+file:///Users/loganwhitt/Desktop/Programming%20Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment#0.1.0","manifest_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"employee_names_to_dapartment","src_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"expected pattern, found `}`","code":null,"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1685,"byte_end":1686,"line_start":72,"line_end":72,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"}","highlight_start":1,"highlight_end":2}],"label":"expected pattern","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: expected pattern, found `}`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mexpected pattern\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/loganwhitt/Desktop/Programming%20Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment#0.1.0","manifest_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"employee_names_to_dapartment","src_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"expected pattern, found `}`","code":null,"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1685,"byte_end":1686,"line_start":72,"line_end":72,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"}","highlight_start":1,"highlight_end":2}],"label":"expected pattern","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: expected pattern, found `}`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mexpected pattern\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/loganwhitt/Desktop/Programming%20Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment#0.1.0","manifest_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"employee_names_to_dapartment","src_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot move out of index of `Vec<String>`","code":{"code":"E0507","explanation":"A borrowed value was moved out.\n\nErroneous code example:\n\n```compile_fail,E0507\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n}\n```\n\nHere, the `nothing_is_true` method takes the ownership of `self`. However,\n`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\nwhich is a borrow of the content owned by the `RefCell`. To fix this error,\nyou have three choices:\n\n* Try to avoid moving the variable.\n* Somehow reclaim the ownership.\n* Implement the `Copy` trait on the type.\n\nThis can also happen when using a type implementing `Fn` or `FnMut`, as neither\nallows moving out of them (they usually represent closures which can be called\nmore than once). Much of the text following applies equally well to non-`FnOnce`\nclosure bodies.\n\nExamples:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(&self) {} // First case, we don't take ownership\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n    let x = x.into_inner(); // we get back ownership\n\n    x.nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\n#[derive(Clone, Copy)] // we implement the Copy trait\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nMoving a member out of a mutably borrowed struct will also cause E0507 error:\n\n```compile_fail,E0507\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nstruct Batcave {\n    knight: TheDarkKnight\n}\n\nfn main() {\n    let mut cave = Batcave {\n        knight: TheDarkKnight\n    };\n    let borrowed = &mut cave;\n\n    borrowed.knight.nothing_is_true(); // E0507\n}\n```\n\nIt is fine only if you put something back. `mem::replace` can be used for that:\n\n```\n# struct TheDarkKnight;\n# impl TheDarkKnight { fn nothing_is_true(self) {} }\n# struct Batcave { knight: TheDarkKnight }\nuse std::mem;\n\nlet mut cave = Batcave {\n    knight: TheDarkKnight\n};\nlet borrowed = &mut cave;\n\nmem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1225,"byte_end":1231,"line_start":51,"line_end":51,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"        let key:String = vec[i];","highlight_start":26,"highlight_end":32}],"label":"move occurs because value has type `String`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider borrowing here","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1225,"byte_end":1225,"line_start":51,"line_end":51,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"        let key:String = vec[i];","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1231,"byte_end":1231,"line_start":51,"line_end":51,"column_start":32,"column_end":32,"is_primary":true,"text":[{"text":"        let key:String = vec[i];","highlight_start":32,"highlight_end":32}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0507]\u001b[0m\u001b[1m: cannot move out of index of `Vec<String>`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:51:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let key:String = vec[i];\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mmove occurs because value has type `String`, which does not implement the `Copy` trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider borrowing here\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        let key:String = \u001b[92m&\u001b[0mvec[i];\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[92m+\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        let key:String = vec[i]\u001b[92m.clone()\u001b[0m;\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/loganwhitt/Desktop/Programming%20Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment#0.1.0","manifest_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"employee_names_to_dapartment","src_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"borrow of moved value: `key`","code":{"code":"E0382","explanation":"A variable was used after its contents have been moved elsewhere.\n\nErroneous code example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`. Implicit\ncloning is more convenient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the\n[Understanding Ownership][understanding-ownership] chapter in the Book.\n\n[understanding-ownership]: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1225,"byte_end":1231,"line_start":51,"line_end":51,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"        let key:String = vec[i];","highlight_start":26,"highlight_end":32}],"label":"this reinitialization might get skipped","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1309,"byte_end":1348,"line_start":56,"line_end":56,"column_start":9,"column_end":48,"is_primary":false,"text":[{"text":"        while overflow == false && vec[j] > key{","highlight_start":9,"highlight_end":48}],"label":"inside of this loop","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":1309,"byte_end":1600,"line_start":56,"line_end":64,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        while overflow == false && vec[j] > key{","highlight_start":9,"highlight_end":49},{"text":"            vec[j+1] = vec[j];","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            let overflow_check = j.checked_sub(1);","highlight_start":1,"highlight_end":51},{"text":"            match overflow_check{","highlight_start":1,"highlight_end":34},{"text":"                Some(i) => {j -= 1; vec[j+1] = key},","highlight_start":1,"highlight_end":53},{"text":"                None => {overflow = true; vec[0] = key},","highlight_start":1,"highlight_end":57},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `while` loop","def_site_span":{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/main.rs","byte_start":1571,"byte_end":1574,"line_start":62,"line_end":62,"column_start":52,"column_end":55,"is_primary":false,"text":[{"text":"                None => {overflow = true; vec[0] = key},","highlight_start":52,"highlight_end":55}],"label":"value moved here, in previous iteration of loop","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1309,"byte_end":1348,"line_start":56,"line_end":56,"column_start":9,"column_end":48,"is_primary":false,"text":[{"text":"        while overflow == false && vec[j] > key{","highlight_start":9,"highlight_end":48}],"label":"inside of this loop","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":1309,"byte_end":1600,"line_start":56,"line_end":64,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        while overflow == false && vec[j] > key{","highlight_start":9,"highlight_end":49},{"text":"            vec[j+1] = vec[j];","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            let overflow_check = j.checked_sub(1);","highlight_start":1,"highlight_end":51},{"text":"            match overflow_check{","highlight_start":1,"highlight_end":34},{"text":"                Some(i) => {j -= 1; vec[j+1] = key},","highlight_start":1,"highlight_end":53},{"text":"                None => {overflow = true; vec[0] = key},","highlight_start":1,"highlight_end":57},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `while` loop","def_site_span":{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/main.rs","byte_start":1514,"byte_end":1517,"line_start":61,"line_end":61,"column_start":48,"column_end":51,"is_primary":false,"text":[{"text":"                Some(i) => {j -= 1; vec[j+1] = key},","highlight_start":48,"highlight_end":51}],"label":"value moved here, in previous iteration of loop","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1345,"byte_end":1348,"line_start":56,"line_end":56,"column_start":45,"column_end":48,"is_primary":true,"text":[{"text":"        while overflow == false && vec[j] > key{","highlight_start":45,"highlight_end":48}],"label":"value borrowed here after move","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1212,"byte_end":1215,"line_start":51,"line_end":51,"column_start":13,"column_end":16,"is_primary":false,"text":[{"text":"        let key:String = vec[i];","highlight_start":13,"highlight_end":16}],"label":"move occurs because `key` has type `String`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1574,"byte_end":1574,"line_start":62,"line_end":62,"column_start":55,"column_end":55,"is_primary":true,"text":[{"text":"                None => {overflow = true; vec[0] = key},","highlight_start":55,"highlight_end":55}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1517,"byte_end":1517,"line_start":61,"line_end":61,"column_start":51,"column_end":51,"is_primary":true,"text":[{"text":"                Some(i) => {j -= 1; vec[j+1] = key},","highlight_start":51,"highlight_end":51}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0382]\u001b[0m\u001b[1m: borrow of moved value: `key`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:56:45\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let key:String = vec[i];\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m---\u001b[0m          \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mthis reinitialization might get skipped\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94mmove occurs because `key` has type `String`, which does not implement the `Copy` trait\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m56\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         while overflow == false && vec[j] > key{\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m------------------------------------\u001b[0m\u001b[1m\u001b[91m^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91mvalue borrowed here after move\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94minside of this loop\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94minside of this loop\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m61\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 Some(i) => {j -= 1; vec[j+1] = key},\n   \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mvalue moved here, in previous iteration of loop\u001b[0m\n\u001b[1m\u001b[94m62\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 None => {overflow = true; vec[0] = key},\n   \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mvalue moved here, in previous iteration of loop\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m62\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                None => {overflow = true; vec[0] = key\u001b[92m.clone()\u001b[0m},\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[92m++++++++\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m61\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                Some(i) => {j -= 1; vec[j+1] = key\u001b[92m.clone()\u001b[0m},\n   \u001b[1m\u001b[94m|\u001b[0m                                                   \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/loganwhitt/Desktop/Programming%20Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment#0.1.0","manifest_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"employee_names_to_dapartment","src_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot move out of index of `Vec<String>`","code":{"code":"E0507","explanation":"A borrowed value was moved out.\n\nErroneous code example:\n\n```compile_fail,E0507\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n}\n```\n\nHere, the `nothing_is_true` method takes the ownership of `self`. However,\n`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\nwhich is a borrow of the content owned by the `RefCell`. To fix this error,\nyou have three choices:\n\n* Try to avoid moving the variable.\n* Somehow reclaim the ownership.\n* Implement the `Copy` trait on the type.\n\nThis can also happen when using a type implementing `Fn` or `FnMut`, as neither\nallows moving out of them (they usually represent closures which can be called\nmore than once). Much of the text following applies equally well to non-`FnOnce`\nclosure bodies.\n\nExamples:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(&self) {} // First case, we don't take ownership\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n    let x = x.into_inner(); // we get back ownership\n\n    x.nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\n#[derive(Clone, Copy)] // we implement the Copy trait\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nMoving a member out of a mutably borrowed struct will also cause E0507 error:\n\n```compile_fail,E0507\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nstruct Batcave {\n    knight: TheDarkKnight\n}\n\nfn main() {\n    let mut cave = Batcave {\n        knight: TheDarkKnight\n    };\n    let borrowed = &mut cave;\n\n    borrowed.knight.nothing_is_true(); // E0507\n}\n```\n\nIt is fine only if you put something back. `mem::replace` can be used for that:\n\n```\n# struct TheDarkKnight;\n# impl TheDarkKnight { fn nothing_is_true(self) {} }\n# struct Batcave { knight: TheDarkKnight }\nuse std::mem;\n\nlet mut cave = Batcave {\n    knight: TheDarkKnight\n};\nlet borrowed = &mut cave;\n\nmem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1373,"byte_end":1379,"line_start":57,"line_end":57,"column_start":24,"column_end":30,"is_primary":true,"text":[{"text":"            vec[j+1] = vec[j];","highlight_start":24,"highlight_end":30}],"label":"move occurs because value has type `String`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1379,"byte_end":1379,"line_start":57,"line_end":57,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"            vec[j+1] = vec[j];","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0507]\u001b[0m\u001b[1m: cannot move out of index of `Vec<String>`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:57:24\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             vec[j+1] = vec[j];\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mmove occurs because value has type `String`, which does not implement the `Copy` trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m57\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            vec[j+1] = vec[j]\u001b[92m.clone()\u001b[0m;\n   \u001b[1m\u001b[94m|\u001b[0m                              \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/loganwhitt/Desktop/Programming%20Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment#0.1.0","manifest_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"employee_names_to_dapartment","src_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `i`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":1488,"byte_end":1489,"line_start":61,"line_end":61,"column_start":22,"column_end":23,"is_primary":true,"text":[{"text":"                Some(i) => {j -= 1; vec[j+1] = key},","highlight_start":22,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1488,"byte_end":1489,"line_start":61,"line_end":61,"column_start":22,"column_end":23,"is_primary":true,"text":[{"text":"                Some(i) => {j -= 1; vec[j+1] = key},","highlight_start":22,"highlight_end":23}],"label":null,"suggested_replacement":"_i","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `i`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:61:22\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m61\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 Some(i) => {j -= 1; vec[j+1] = key},\n   \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[33m^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_i`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/loganwhitt/Desktop/Programming%20Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment#0.1.0","manifest_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"employee_names_to_dapartment","src_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `database`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":2218,"byte_end":2226,"line_start":102,"line_end":102,"column_start":9,"column_end":17,"is_primary":true,"text":[{"text":"fn menu(database: &mut HashMap<String, Vec<String>>){","highlight_start":9,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":2218,"byte_end":2226,"line_start":102,"line_end":102,"column_start":9,"column_end":17,"is_primary":true,"text":[{"text":"fn menu(database: &mut HashMap<String, Vec<String>>){","highlight_start":9,"highlight_end":17}],"label":null,"suggested_replacement":"_database","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `database`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:102:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m102\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn menu(database: &mut HashMap<String, Vec<String>>){\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_database`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/loganwhitt/Desktop/Programming%20Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment#0.1.0","manifest_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"employee_names_to_dapartment","src_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0382, E0507.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0382, E0507.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/loganwhitt/Desktop/Programming%20Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment#0.1.0","manifest_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"employee_names_to_dapartment","src_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0382`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0382`.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/loganwhitt/Desktop/Programming%20Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment#0.1.0","manifest_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"employee_names_to_dapartment","src_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot move out of index of `Vec<String>`","code":{"code":"E0507","explanation":"A borrowed value was moved out.\n\nErroneous code example:\n\n```compile_fail,E0507\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n}\n```\n\nHere, the `nothing_is_true` method takes the ownership of `self`. However,\n`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\nwhich is a borrow of the content owned by the `RefCell`. To fix this error,\nyou have three choices:\n\n* Try to avoid moving the variable.\n* Somehow reclaim the ownership.\n* Implement the `Copy` trait on the type.\n\nThis can also happen when using a type implementing `Fn` or `FnMut`, as neither\nallows moving out of them (they usually represent closures which can be called\nmore than once). Much of the text following applies equally well to non-`FnOnce`\nclosure bodies.\n\nExamples:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(&self) {} // First case, we don't take ownership\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n    let x = x.into_inner(); // we get back ownership\n\n    x.nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\n#[derive(Clone, Copy)] // we implement the Copy trait\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nMoving a member out of a mutably borrowed struct will also cause E0507 error:\n\n```compile_fail,E0507\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nstruct Batcave {\n    knight: TheDarkKnight\n}\n\nfn main() {\n    let mut cave = Batcave {\n        knight: TheDarkKnight\n    };\n    let borrowed = &mut cave;\n\n    borrowed.knight.nothing_is_true(); // E0507\n}\n```\n\nIt is fine only if you put something back. `mem::replace` can be used for that:\n\n```\n# struct TheDarkKnight;\n# impl TheDarkKnight { fn nothing_is_true(self) {} }\n# struct Batcave { knight: TheDarkKnight }\nuse std::mem;\n\nlet mut cave = Batcave {\n    knight: TheDarkKnight\n};\nlet borrowed = &mut cave;\n\nmem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1225,"byte_end":1231,"line_start":51,"line_end":51,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"        let key:String = vec[i];","highlight_start":26,"highlight_end":32}],"label":"move occurs because value has type `String`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider borrowing here","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1225,"byte_end":1225,"line_start":51,"line_end":51,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"        let key:String = vec[i];","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1231,"byte_end":1231,"line_start":51,"line_end":51,"column_start":32,"column_end":32,"is_primary":true,"text":[{"text":"        let key:String = vec[i];","highlight_start":32,"highlight_end":32}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0507]\u001b[0m\u001b[1m: cannot move out of index of `Vec<String>`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:51:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let key:String = vec[i];\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mmove occurs because value has type `String`, which does not implement the `Copy` trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider borrowing here\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        let key:String = \u001b[92m&\u001b[0mvec[i];\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[92m+\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        let key:String = vec[i]\u001b[92m.clone()\u001b[0m;\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/loganwhitt/Desktop/Programming%20Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment#0.1.0","manifest_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"employee_names_to_dapartment","src_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"borrow of moved value: `key`","code":{"code":"E0382","explanation":"A variable was used after its contents have been moved elsewhere.\n\nErroneous code example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`. Implicit\ncloning is more convenient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the\n[Understanding Ownership][understanding-ownership] chapter in the Book.\n\n[understanding-ownership]: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1225,"byte_end":1231,"line_start":51,"line_end":51,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"        let key:String = vec[i];","highlight_start":26,"highlight_end":32}],"label":"this reinitialization might get skipped","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1309,"byte_end":1348,"line_start":56,"line_end":56,"column_start":9,"column_end":48,"is_primary":false,"text":[{"text":"        while overflow == false && vec[j] > key{","highlight_start":9,"highlight_end":48}],"label":"inside of this loop","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":1309,"byte_end":1600,"line_start":56,"line_end":64,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        while overflow == false && vec[j] > key{","highlight_start":9,"highlight_end":49},{"text":"            vec[j+1] = vec[j];","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            let overflow_check = j.checked_sub(1);","highlight_start":1,"highlight_end":51},{"text":"            match overflow_check{","highlight_start":1,"highlight_end":34},{"text":"                Some(i) => {j -= 1; vec[j+1] = key},","highlight_start":1,"highlight_end":53},{"text":"                None => {overflow = true; vec[0] = key},","highlight_start":1,"highlight_end":57},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `while` loop","def_site_span":{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/main.rs","byte_start":1571,"byte_end":1574,"line_start":62,"line_end":62,"column_start":52,"column_end":55,"is_primary":false,"text":[{"text":"                None => {overflow = true; vec[0] = key},","highlight_start":52,"highlight_end":55}],"label":"value moved here, in previous iteration of loop","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1309,"byte_end":1348,"line_start":56,"line_end":56,"column_start":9,"column_end":48,"is_primary":false,"text":[{"text":"        while overflow == false && vec[j] > key{","highlight_start":9,"highlight_end":48}],"label":"inside of this loop","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":1309,"byte_end":1600,"line_start":56,"line_end":64,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        while overflow == false && vec[j] > key{","highlight_start":9,"highlight_end":49},{"text":"            vec[j+1] = vec[j];","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            let overflow_check = j.checked_sub(1);","highlight_start":1,"highlight_end":51},{"text":"            match overflow_check{","highlight_start":1,"highlight_end":34},{"text":"                Some(i) => {j -= 1; vec[j+1] = key},","highlight_start":1,"highlight_end":53},{"text":"                None => {overflow = true; vec[0] = key},","highlight_start":1,"highlight_end":57},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `while` loop","def_site_span":{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/main.rs","byte_start":1514,"byte_end":1517,"line_start":61,"line_end":61,"column_start":48,"column_end":51,"is_primary":false,"text":[{"text":"                Some(i) => {j -= 1; vec[j+1] = key},","highlight_start":48,"highlight_end":51}],"label":"value moved here, in previous iteration of loop","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1345,"byte_end":1348,"line_start":56,"line_end":56,"column_start":45,"column_end":48,"is_primary":true,"text":[{"text":"        while overflow == false && vec[j] > key{","highlight_start":45,"highlight_end":48}],"label":"value borrowed here after move","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1212,"byte_end":1215,"line_start":51,"line_end":51,"column_start":13,"column_end":16,"is_primary":false,"text":[{"text":"        let key:String = vec[i];","highlight_start":13,"highlight_end":16}],"label":"move occurs because `key` has type `String`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1574,"byte_end":1574,"line_start":62,"line_end":62,"column_start":55,"column_end":55,"is_primary":true,"text":[{"text":"                None => {overflow = true; vec[0] = key},","highlight_start":55,"highlight_end":55}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1517,"byte_end":1517,"line_start":61,"line_end":61,"column_start":51,"column_end":51,"is_primary":true,"text":[{"text":"                Some(i) => {j -= 1; vec[j+1] = key},","highlight_start":51,"highlight_end":51}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0382]\u001b[0m\u001b[1m: borrow of moved value: `key`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:56:45\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let key:String = vec[i];\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m---\u001b[0m          \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mthis reinitialization might get skipped\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94mmove occurs because `key` has type `String`, which does not implement the `Copy` trait\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m56\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         while overflow == false && vec[j] > key{\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m------------------------------------\u001b[0m\u001b[1m\u001b[91m^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91mvalue borrowed here after move\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94minside of this loop\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94minside of this loop\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m61\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 Some(i) => {j -= 1; vec[j+1] = key},\n   \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mvalue moved here, in previous iteration of loop\u001b[0m\n\u001b[1m\u001b[94m62\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 None => {overflow = true; vec[0] = key},\n   \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mvalue moved here, in previous iteration of loop\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m62\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                None => {overflow = true; vec[0] = key\u001b[92m.clone()\u001b[0m},\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[92m++++++++\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m61\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                Some(i) => {j -= 1; vec[j+1] = key\u001b[92m.clone()\u001b[0m},\n   \u001b[1m\u001b[94m|\u001b[0m                                                   \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/loganwhitt/Desktop/Programming%20Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment#0.1.0","manifest_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"employee_names_to_dapartment","src_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot move out of index of `Vec<String>`","code":{"code":"E0507","explanation":"A borrowed value was moved out.\n\nErroneous code example:\n\n```compile_fail,E0507\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n}\n```\n\nHere, the `nothing_is_true` method takes the ownership of `self`. However,\n`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\nwhich is a borrow of the content owned by the `RefCell`. To fix this error,\nyou have three choices:\n\n* Try to avoid moving the variable.\n* Somehow reclaim the ownership.\n* Implement the `Copy` trait on the type.\n\nThis can also happen when using a type implementing `Fn` or `FnMut`, as neither\nallows moving out of them (they usually represent closures which can be called\nmore than once). Much of the text following applies equally well to non-`FnOnce`\nclosure bodies.\n\nExamples:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(&self) {} // First case, we don't take ownership\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n    let x = x.into_inner(); // we get back ownership\n\n    x.nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\n#[derive(Clone, Copy)] // we implement the Copy trait\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nMoving a member out of a mutably borrowed struct will also cause E0507 error:\n\n```compile_fail,E0507\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nstruct Batcave {\n    knight: TheDarkKnight\n}\n\nfn main() {\n    let mut cave = Batcave {\n        knight: TheDarkKnight\n    };\n    let borrowed = &mut cave;\n\n    borrowed.knight.nothing_is_true(); // E0507\n}\n```\n\nIt is fine only if you put something back. `mem::replace` can be used for that:\n\n```\n# struct TheDarkKnight;\n# impl TheDarkKnight { fn nothing_is_true(self) {} }\n# struct Batcave { knight: TheDarkKnight }\nuse std::mem;\n\nlet mut cave = Batcave {\n    knight: TheDarkKnight\n};\nlet borrowed = &mut cave;\n\nmem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1373,"byte_end":1379,"line_start":57,"line_end":57,"column_start":24,"column_end":30,"is_primary":true,"text":[{"text":"            vec[j+1] = vec[j];","highlight_start":24,"highlight_end":30}],"label":"move occurs because value has type `String`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1379,"byte_end":1379,"line_start":57,"line_end":57,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"            vec[j+1] = vec[j];","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0507]\u001b[0m\u001b[1m: cannot move out of index of `Vec<String>`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:57:24\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             vec[j+1] = vec[j];\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mmove occurs because value has type `String`, which does not implement the `Copy` trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m57\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            vec[j+1] = vec[j]\u001b[92m.clone()\u001b[0m;\n   \u001b[1m\u001b[94m|\u001b[0m                              \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/loganwhitt/Desktop/Programming%20Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment#0.1.0","manifest_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"employee_names_to_dapartment","src_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `i`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":1488,"byte_end":1489,"line_start":61,"line_end":61,"column_start":22,"column_end":23,"is_primary":true,"text":[{"text":"                Some(i) => {j -= 1; vec[j+1] = key},","highlight_start":22,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1488,"byte_end":1489,"line_start":61,"line_end":61,"column_start":22,"column_end":23,"is_primary":true,"text":[{"text":"                Some(i) => {j -= 1; vec[j+1] = key},","highlight_start":22,"highlight_end":23}],"label":null,"suggested_replacement":"_i","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `i`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:61:22\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m61\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 Some(i) => {j -= 1; vec[j+1] = key},\n   \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[33m^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_i`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/loganwhitt/Desktop/Programming%20Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment#0.1.0","manifest_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"employee_names_to_dapartment","src_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `database`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":2218,"byte_end":2226,"line_start":102,"line_end":102,"column_start":9,"column_end":17,"is_primary":true,"text":[{"text":"fn menu(database: &mut HashMap<String, Vec<String>>){","highlight_start":9,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":2218,"byte_end":2226,"line_start":102,"line_end":102,"column_start":9,"column_end":17,"is_primary":true,"text":[{"text":"fn menu(database: &mut HashMap<String, Vec<String>>){","highlight_start":9,"highlight_end":17}],"label":null,"suggested_replacement":"_database","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `database`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:102:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m102\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn menu(database: &mut HashMap<String, Vec<String>>){\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_database`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/loganwhitt/Desktop/Programming%20Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment#0.1.0","manifest_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"employee_names_to_dapartment","src_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0382, E0507.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0382, E0507.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/loganwhitt/Desktop/Programming%20Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment#0.1.0","manifest_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"employee_names_to_dapartment","src_path":"/Users/loganwhitt/Desktop/Programming Files/Rust/Rust_lang_doc/Chapter8_Common_Collections/employee_names_to_dapartment/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0382`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0382`.\u001b[0m\n"}}
{"reason":"build-finished","success":false}
